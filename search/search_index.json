{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"VPSim Introduction Wath is VPSim ? Use Key VPSim concepts Speed and interoperability Transportation, industry, security & defense Getting Started Installation Demo Package Contents Clone & Build Requirements Configure Getting Started Simulation Models Launching a simulation Benchmarking Ending a simulation Documentation UML User Documentation Developer/Expert Documentation","title":"VPSim"},{"location":"#vpsim","text":"","title":"VPSim"},{"location":"#introduction","text":"Wath is VPSim ? Use Key VPSim concepts Speed and interoperability Transportation, industry, security & defense","title":"Introduction"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#installation","text":"Demo Package Contents Clone & Build Requirements Configure Getting Started","title":"Installation"},{"location":"#simulation","text":"Models Launching a simulation Benchmarking Ending a simulation","title":"Simulation"},{"location":"#documentation","text":"UML User Documentation Developer/Expert Documentation","title":"Documentation"},{"location":"ExpertDocumentation/","text":"Developer/Expert Documentation Why would you need a dynamic instanciation ? Actually, if you want to build a full system using systemC you will have to instantiate your modules statically. This can be a problem if you want to do automatic exploration of architectures because you will have to recompose your system and recompile your code on each minor/major modification. There is several benefits to use a dynamic instantiation: 1) Parametrization and Configurability: Dynamic instantiation allows you to parametrize your modules dynamically, making them more configurable. This is useful for example, when you want to create multiple instances of the same module with a different configuration. 2) Reusability: You can create generic modules that can be instantiated multiple times with different parameters making it easier to reuse components in different parts of your design simulated. 3) Flexible System Composition: Dynamic instantiation provides the flexibility to compose your system by adding or removing modules based on the specific requirements of the simulation. VPSim approach In VPSim, we use a dynamic instantiation of the different systemC modules that will compose your system. We also automatically bind those modules between them by using a specific process that I will explain in the dynamic instantiation process part. This approach allows you to have only one executable file for all the architectures you want to explore without having to recompile the entire model each time. Dynamic instanciation of modules in VPSim For this part, I advise you to look at the UML diagram of the dynamic instanciation process. 1) SesamIp class : SesamIp is an abstract class that is here to define all the properties and functions/methods that an IP would need to be integrated in VPSim (number of in/out ports, stats of the module, required/optional attributes, port binding\u2026). It contains a static attribute called RegisteredClasses, which represents all the known classes of components (systemC modules) that VPSim can dynamically instantiate for a system build. 2) DynamicComponents : DynamicComponents is a file where you define a structure for each systemC modules you would like to instantiate dynamically in VPSim. Each structure in this file inherits from SesamIp class and contains a member, which is a pointer to a systemC module. This allow you to define specific rules and behaviours for each SystemC modules you want to include in VPSim by overloading the virtual methods declared in SesamIp class. Each structure need to be registered in the RegisteredClasses static attribute to dynamically be instantiated in VPSim. 3) PlatformBuilder : PlatformBuilder is structure used to construct a platform (collection of SesamIp instances). The goal of PlatformBuilder is to instantiate all the IPs described in the XML, bind their ports (the in/out ports of each modules are identified with a Port Alias or automatically binded), and then finalize the module (if you need to consider other systemC modules in your implementation). In short, it builds the platform, binds the ports of each modules and finalizes the modules. The order of instantiation does not count in VPSim . All the modules are instantiated and then binded automatically or with port aliases specified in the XML. When all the modules are instantiated and binded, there is the finalization phase (if a module needs to consider another module to work has expected). Global approach SesamIp class SesamIp is an abstract class that is here to define all the properties and functions/methods that an IP would need to be integrated in VPSim (number of in/out ports, stats of the module, required/optional attributes, port binding\u2026). It contains a static attribute called RegisteredClasses, which represents all the known classes of components (systemC modules) that VPSim can dynamically instantiate for a system build. DynamicComponents class DynamicComponents is a file where you define a structure for each systemC modules you would like to instantiate dynamically in VPSim. Each structure in this file inherits from SesamIp class and contains a member, which is a pointer to a systemC module. This allow you to define specific rules and behaviours for each SystemC modules you want to include in VPSim by overloading the virtual methods declared in SesamIp class. Each structure need to be registered in the RegisteredClasses static attribute to dynamically be instantiated in VPSim. PlatformBuilder class PlatformBuilder is structure used to construct a platform (collection of SesamIp instances). The goal of PlatformBuilder is to instantiate all the IPs described in the XML, bind their ports (the in/out ports of each modules are identified with a Port Alias or automatically binded), and then finalize the module (if you need to consider other systemC modules in your implementation). In short, it builds the platform, binds the ports of each modules and finalizes the modules. Dynamic instanciation process Here is a simple representation of the dynamic instanciation process in VPSim: Steps to add a new systemC module into VPSim 1) Include your systemC module into the dynamicComponent file so that you can reference it in a structure. 2) Define the DynamicModuleName structure related to your systemC module : - Define the required/optional attributes of the module in the constructor - Create a pointer to the actual SystemC module has a member of your structure - Overload the virtual functions of the sesamIp class. You have to overload at least the make function (Make() to instantiate the module and create a pointer to the actual systeC module) and the finalize function if you need to do something with the module in relation with other instances ONCE ALL THE OTHER MODULES ARE INSTANCIATED. 3) Register the structure you have just defined by calling registerClass (\u201cNameForXMLInterpretation\u201d) in the main. This will allow you to use it in the XML with the name \u201cNameForXMLInterpretation\u201d. Then the dynamic instantiation will be handled by platformBuilder (following the XML description of the platform). Concrete exemple of the make and finalize functions : a NoC memory controller Let\u2019s say you want to add a NoC memory controller into VPSim. You will have to create a new structure into DynamicComponents.hpp called \u201cDynamicNocMemoryController\u201d that inherits from SesamIp class. Constructor: For the constructor of this structure you will have to give a name as a parameter to the constructor to create a unique SesamIp object (since it inherits from sesamIp). In this constructor, you will define at least the required attributes of a NoC memory controller by calling registerRequiredAttribute from the sesamIp class. These are the required attributes for NoC memory controller: - Size represents the size that the NoC memory controller will handle - Base_address represents the base address on which the NoC memory controller starts - Noc represents the name of the NoC on which the memory controller will be assigned - x_id represents the abscissa position on the NoC where the memory controller will be assigned - y_id represents the ordinate position on the NoC where the memory controller will be assigned make function: In VPSim a memory controller isn\u2019t really a systemC module. It is a structure that defines for a NoC on which position is assigned a memory component. In this case, you only override the make function to check if the required attributes are all specified in the XML by calling the checkAttribute function from SesamIp class. finalize function: Has said, finalize is called only when all the modules that compose your platform are instantiated (so the make function has already been called on each modules). The difference between the two functions is that in finalize, you can consider other IP instances (has all the modules are instantiated). In this case, we first create a pointer to the NoC instance you want to assign the NoC memory controller. Then, since you have a pointer to the actual instance of the NoC module, we defined a function in our NoC module called register_mem_ctrl that indicates to the NoC that at the position x_id, y_id are the memory addresses base_address+size. Therefore, you simply call this function on the NoC module pointer by giving as parameters the attributes of the NoC memory controller.","title":"Developer Documentation"},{"location":"ExpertDocumentation/#developerexpert-documentation","text":"","title":"Developer/Expert Documentation"},{"location":"ExpertDocumentation/#why-would-you-need-a-dynamic-instanciation","text":"Actually, if you want to build a full system using systemC you will have to instantiate your modules statically. This can be a problem if you want to do automatic exploration of architectures because you will have to recompose your system and recompile your code on each minor/major modification. There is several benefits to use a dynamic instantiation: 1) Parametrization and Configurability: Dynamic instantiation allows you to parametrize your modules dynamically, making them more configurable. This is useful for example, when you want to create multiple instances of the same module with a different configuration. 2) Reusability: You can create generic modules that can be instantiated multiple times with different parameters making it easier to reuse components in different parts of your design simulated. 3) Flexible System Composition: Dynamic instantiation provides the flexibility to compose your system by adding or removing modules based on the specific requirements of the simulation.","title":"Why would you need a dynamic instanciation ?"},{"location":"ExpertDocumentation/#vpsim-approach","text":"In VPSim, we use a dynamic instantiation of the different systemC modules that will compose your system. We also automatically bind those modules between them by using a specific process that I will explain in the dynamic instantiation process part. This approach allows you to have only one executable file for all the architectures you want to explore without having to recompile the entire model each time.","title":"VPSim approach"},{"location":"ExpertDocumentation/#dynamic-instanciation-of-modules-in-vpsim","text":"For this part, I advise you to look at the UML diagram of the dynamic instanciation process. 1) SesamIp class : SesamIp is an abstract class that is here to define all the properties and functions/methods that an IP would need to be integrated in VPSim (number of in/out ports, stats of the module, required/optional attributes, port binding\u2026). It contains a static attribute called RegisteredClasses, which represents all the known classes of components (systemC modules) that VPSim can dynamically instantiate for a system build. 2) DynamicComponents : DynamicComponents is a file where you define a structure for each systemC modules you would like to instantiate dynamically in VPSim. Each structure in this file inherits from SesamIp class and contains a member, which is a pointer to a systemC module. This allow you to define specific rules and behaviours for each SystemC modules you want to include in VPSim by overloading the virtual methods declared in SesamIp class. Each structure need to be registered in the RegisteredClasses static attribute to dynamically be instantiated in VPSim. 3) PlatformBuilder : PlatformBuilder is structure used to construct a platform (collection of SesamIp instances). The goal of PlatformBuilder is to instantiate all the IPs described in the XML, bind their ports (the in/out ports of each modules are identified with a Port Alias or automatically binded), and then finalize the module (if you need to consider other systemC modules in your implementation). In short, it builds the platform, binds the ports of each modules and finalizes the modules. The order of instantiation does not count in VPSim . All the modules are instantiated and then binded automatically or with port aliases specified in the XML. When all the modules are instantiated and binded, there is the finalization phase (if a module needs to consider another module to work has expected).","title":"Dynamic instanciation of modules in VPSim"},{"location":"ExpertDocumentation/#global-approach","text":"","title":"Global approach"},{"location":"ExpertDocumentation/#sesamip-class","text":"SesamIp is an abstract class that is here to define all the properties and functions/methods that an IP would need to be integrated in VPSim (number of in/out ports, stats of the module, required/optional attributes, port binding\u2026). It contains a static attribute called RegisteredClasses, which represents all the known classes of components (systemC modules) that VPSim can dynamically instantiate for a system build.","title":"SesamIp class"},{"location":"ExpertDocumentation/#dynamiccomponents-class","text":"DynamicComponents is a file where you define a structure for each systemC modules you would like to instantiate dynamically in VPSim. Each structure in this file inherits from SesamIp class and contains a member, which is a pointer to a systemC module. This allow you to define specific rules and behaviours for each SystemC modules you want to include in VPSim by overloading the virtual methods declared in SesamIp class. Each structure need to be registered in the RegisteredClasses static attribute to dynamically be instantiated in VPSim.","title":"DynamicComponents class"},{"location":"ExpertDocumentation/#platformbuilder-class","text":"PlatformBuilder is structure used to construct a platform (collection of SesamIp instances). The goal of PlatformBuilder is to instantiate all the IPs described in the XML, bind their ports (the in/out ports of each modules are identified with a Port Alias or automatically binded), and then finalize the module (if you need to consider other systemC modules in your implementation). In short, it builds the platform, binds the ports of each modules and finalizes the modules.","title":"PlatformBuilder class"},{"location":"ExpertDocumentation/#dynamic-instanciation-process","text":"Here is a simple representation of the dynamic instanciation process in VPSim:","title":"Dynamic instanciation process"},{"location":"ExpertDocumentation/#steps-to-add-a-new-systemc-module-into-vpsim","text":"1) Include your systemC module into the dynamicComponent file so that you can reference it in a structure. 2) Define the DynamicModuleName structure related to your systemC module : - Define the required/optional attributes of the module in the constructor - Create a pointer to the actual SystemC module has a member of your structure - Overload the virtual functions of the sesamIp class. You have to overload at least the make function (Make() to instantiate the module and create a pointer to the actual systeC module) and the finalize function if you need to do something with the module in relation with other instances ONCE ALL THE OTHER MODULES ARE INSTANCIATED. 3) Register the structure you have just defined by calling registerClass (\u201cNameForXMLInterpretation\u201d) in the main. This will allow you to use it in the XML with the name \u201cNameForXMLInterpretation\u201d. Then the dynamic instantiation will be handled by platformBuilder (following the XML description of the platform).","title":"Steps to add a new systemC module into VPSim"},{"location":"ExpertDocumentation/#concrete-exemple-of-the-make-and-finalize-functions-a-noc-memory-controller","text":"Let\u2019s say you want to add a NoC memory controller into VPSim. You will have to create a new structure into DynamicComponents.hpp called \u201cDynamicNocMemoryController\u201d that inherits from SesamIp class. Constructor: For the constructor of this structure you will have to give a name as a parameter to the constructor to create a unique SesamIp object (since it inherits from sesamIp). In this constructor, you will define at least the required attributes of a NoC memory controller by calling registerRequiredAttribute from the sesamIp class. These are the required attributes for NoC memory controller: - Size represents the size that the NoC memory controller will handle - Base_address represents the base address on which the NoC memory controller starts - Noc represents the name of the NoC on which the memory controller will be assigned - x_id represents the abscissa position on the NoC where the memory controller will be assigned - y_id represents the ordinate position on the NoC where the memory controller will be assigned make function: In VPSim a memory controller isn\u2019t really a systemC module. It is a structure that defines for a NoC on which position is assigned a memory component. In this case, you only override the make function to check if the required attributes are all specified in the XML by calling the checkAttribute function from SesamIp class. finalize function: Has said, finalize is called only when all the modules that compose your platform are instantiated (so the make function has already been called on each modules). The difference between the two functions is that in finalize, you can consider other IP instances (has all the modules are instantiated). In this case, we first create a pointer to the NoC instance you want to assign the NoC memory controller. Then, since you have a pointer to the actual instance of the NoC module, we defined a function in our NoC module called register_mem_ctrl that indicates to the NoC that at the position x_id, y_id are the memory addresses base_address+size. Therefore, you simply call this function on the NoC module pointer by giving as parameters the attributes of the NoC memory controller.","title":"Concrete exemple of the make and finalize functions : a NoC memory controller"},{"location":"UserDocumentation/","text":"User Documentation Simplified representation of the interaction between the release and the binary of VPSim Release global approach gpp.py gpp.py is the first python layer to describe the architecture. It contains a dictionary of pairs attribute:value that will influence the second python layer, which I will talk about after. The goal of gpp.py is to describe a platform simply. This first layer makes VPSim easier to use but also facilitates design space exploration (for example, you can just change the numbers of cores very easily\u2026) armv8_platform.py armv8_platform.py is the second python layer. The goal of this file is to complete the description of gpp.py, depending on the attributes and their value. Armv8_platform describe the architecture at more concrete and low-level. It\u2019s a template of the Armv8 architecture. dt.py dt.py is a python file that dynamically generate a device tree source/blob(dts/dtb) files that will be given to the kernel. The generation is dynamic because it depends on the characteristics of the platform described in the first two python layers (gpp & armv8_platform .py). VPSim.py VPsim.py contains several classes used to generate the XML description of the platform built, considering all the python layers (gpp and armv8_platform). It also contains the location of the dtb file generated for the kernel. Then, the generated XML will be given to the VPSim binary so that it can dynamically instantiate the modules and bind their sockets.","title":"User Documentation"},{"location":"UserDocumentation/#user-documentation","text":"","title":"User Documentation"},{"location":"UserDocumentation/#simplified-representation-of-the-interaction-between-the-release-and-the-binary-of-vpsim","text":"","title":"Simplified representation of the interaction between the release and the binary of VPSim"},{"location":"UserDocumentation/#release-global-approach","text":"gpp.py gpp.py is the first python layer to describe the architecture. It contains a dictionary of pairs attribute:value that will influence the second python layer, which I will talk about after. The goal of gpp.py is to describe a platform simply. This first layer makes VPSim easier to use but also facilitates design space exploration (for example, you can just change the numbers of cores very easily\u2026) armv8_platform.py armv8_platform.py is the second python layer. The goal of this file is to complete the description of gpp.py, depending on the attributes and their value. Armv8_platform describe the architecture at more concrete and low-level. It\u2019s a template of the Armv8 architecture. dt.py dt.py is a python file that dynamically generate a device tree source/blob(dts/dtb) files that will be given to the kernel. The generation is dynamic because it depends on the characteristics of the platform described in the first two python layers (gpp & armv8_platform .py). VPSim.py VPsim.py contains several classes used to generate the XML description of the platform built, considering all the python layers (gpp and armv8_platform). It also contains the location of the dtb file generated for the kernel. Then, the generated XML will be given to the VPSim binary so that it can dynamically instantiate the modules and bind their sockets.","title":"Release global approach"},{"location":"VPSim/","text":"Introduction VPSim Wath is VPSim ? VPSim is a digital architecture design environment used to speed up design space exploration (DSE) through simulation and rapid validation. Users can model a complex memory hierarchy and estimate its performance, for example, thanks to a wide variety of available processor and device models. Use Electronic systems engineers have to meet a wide array of requirements, from performance, form factor, and cost to power consumption and heat dissipation. This means making an equally wide array of complex architecture choices. VPSim leverages CEA-List\u2019s embedded systems know-how to help designers quickly explore potential architecture choices so that they can come up with a solution optimized for the target system. It ensures that all requirements\u2014power consumption, energy dissipation, latency, and form factor\u2014are satisfied. Key VPSim concepts The VPSim digital architecture design environment enables rapid design space exploration, virtual prototyping, and high-level validation\u2014during the design phase\u2014of complex digital systems. VPSim addresses all design process steps holistically with: A rich component library for efficient SystemC model construction Rapid (up to 600 MIPS) virtual prototyping simulation Co-simulation with hardware emulation capabilities It can also estimate extra-functional properties like power and temperature. Finally, VPSim supports the FMI (functional mock-up interface) standard, which means it can interface with other simulation tools so that the behavior of the physical environment can be incorporated into the validation testing of complex cyberphysical systems (CPS). VPSim also has a virtual prototyping component based on QEMU, an open-source emulator with a variety of processor and other device models, that can model complex memory hierarchies and rapidly generate prototypes. Virtual architecture prototyping based on existing components is done in Python. The Python description abstracts the underlying complexity, making it ideal for design space exploration. Another way VPSim can improve design quality is by providing an effective selection of architecture solutions. These solutions are based on operational research methods and learning methods. The latter help automate the refinement of temporal and power models from their RTL descriptions, speeding up the design space exploration process. Speed and interoperability VPSim offers a number of advantages: Fast DSE to meet designers\u2019 needs An end-to-end environment that covers everything from virtual prototyping to RTL validation SystemC/TLM 2.0 for model interoperability The tool supports the FMI standard so that the behavior of the system\u2019s physical environment can be integrated into validation tests QEMU , with its fast processor simulation capabilities Transportation, industry, security & defense VPSim is ideal for the following applications: High-performance computing (HPC): modeling of the future European high-performance processor for the European Processor Initiative (EPI) Transportation: validation of a multi-chip centralized control architecture for a car manufacturer Industry: validation of controller software execution on a virtual integrated circuit platform (digital twin) and FMI co-simulation for modeling of the physical environment\u2019s interactions Security & defense: current leakage assessment for a security analysis","title":"Introduction"},{"location":"VPSim/#introduction","text":"VPSim","title":"Introduction"},{"location":"VPSim/#wath-is-vpsim","text":"VPSim is a digital architecture design environment used to speed up design space exploration (DSE) through simulation and rapid validation. Users can model a complex memory hierarchy and estimate its performance, for example, thanks to a wide variety of available processor and device models.","title":"Wath is VPSim ?"},{"location":"VPSim/#use","text":"Electronic systems engineers have to meet a wide array of requirements, from performance, form factor, and cost to power consumption and heat dissipation. This means making an equally wide array of complex architecture choices. VPSim leverages CEA-List\u2019s embedded systems know-how to help designers quickly explore potential architecture choices so that they can come up with a solution optimized for the target system. It ensures that all requirements\u2014power consumption, energy dissipation, latency, and form factor\u2014are satisfied.","title":"Use"},{"location":"VPSim/#key-vpsim-concepts","text":"The VPSim digital architecture design environment enables rapid design space exploration, virtual prototyping, and high-level validation\u2014during the design phase\u2014of complex digital systems. VPSim addresses all design process steps holistically with: A rich component library for efficient SystemC model construction Rapid (up to 600 MIPS) virtual prototyping simulation Co-simulation with hardware emulation capabilities It can also estimate extra-functional properties like power and temperature. Finally, VPSim supports the FMI (functional mock-up interface) standard, which means it can interface with other simulation tools so that the behavior of the physical environment can be incorporated into the validation testing of complex cyberphysical systems (CPS). VPSim also has a virtual prototyping component based on QEMU, an open-source emulator with a variety of processor and other device models, that can model complex memory hierarchies and rapidly generate prototypes. Virtual architecture prototyping based on existing components is done in Python. The Python description abstracts the underlying complexity, making it ideal for design space exploration. Another way VPSim can improve design quality is by providing an effective selection of architecture solutions. These solutions are based on operational research methods and learning methods. The latter help automate the refinement of temporal and power models from their RTL descriptions, speeding up the design space exploration process.","title":"Key VPSim concepts"},{"location":"VPSim/#speed-and-interoperability","text":"VPSim offers a number of advantages: Fast DSE to meet designers\u2019 needs An end-to-end environment that covers everything from virtual prototyping to RTL validation SystemC/TLM 2.0 for model interoperability The tool supports the FMI standard so that the behavior of the system\u2019s physical environment can be integrated into validation tests QEMU , with its fast processor simulation capabilities","title":"Speed and interoperability"},{"location":"VPSim/#transportation-industry-security-defense","text":"VPSim is ideal for the following applications: High-performance computing (HPC): modeling of the future European high-performance processor for the European Processor Initiative (EPI) Transportation: validation of a multi-chip centralized control architecture for a car manufacturer Industry: validation of controller software execution on a virtual integrated circuit platform (digital twin) and FMI co-simulation for modeling of the physical environment\u2019s interactions Security & defense: current leakage assessment for a security analysis","title":"Transportation, industry, security &amp; defense"},{"location":"installation/","text":"Installation Demo Package Contents bin (/bin): Contains vpsim binary. After each simulation run, a specific folder is created here with files & results of the simulated architecture. lib (/lib): holds the modified qemu library ( ./qemu/vpsim-qemu.so ) GPP (/GPP): Contains configuration python scripts as well as linux kernel and disk image. Configure and simulate a multi-core ARMv8 system running a minimal operating system. Python (/Python): Platforms/armv8_platform.py : gives a versatile, generic ARMv8 System script that generates and configures its components based on a higher-level description. In order to abstract away for the user the whole work of composition. Libs/dt.py : generates the Device Tree to automate the process of configuring hardware components for the simulated architecture. Libs/vpsim.py : generates the final xml of the simulated architecture. SESAM userspace (/SESAM_userspace) : source code for a user space software tool used to control over the simulator for monitoring purposes and collect statistics following the execution of a specific user application and makes it possible to perform an entire exploration task. Clone & Build Clone this git repository and update its submodules: git clone git@github.com:CEA-LIST/VPSim.git cd vpsim git submodule init git submodule update --recursive Build targets and copy artifacts to the release directory ./vpsim-release sub-directory: to do so, we configured a custom command in CMakeLists that rename and copy the targets to the appropriate folder in the release test environment mkdir build && cd build cmake .. make all -j cd ../ Requirements You will need to install dtc device tree compiler: apt install device-tree-compiler To build VPSim & the modified QEMU on a fresh Ubuntu 22.04 LTS installation, you will need to install these libraries: apt install pkg-config apt install libglib2.0-dev apt install libpixman-1-dev For the modified qemu, as it is based on an old version you will need Python2 to be installed : apt install python2 and export it in your shell: export PYTHON=/usr/bin/python2 Now your environment is set, please follow the following steps: Configure Once you realized the steps in the parent README, you can verify the existence of these two main targets as follows: - vpsim -> \"vpsim_release/bin/\" - qemu-system-aarch64 renamed to vpsim-qemu.so -> \"vpsim_release/lib/qemu/\" Configure environment variables by sourcing the ( setup.sh ) script: source setup.sh - **NOTE**: This command must be run in the root directory of VPSim release. - **NOTE**: The disk image `busybox.qcow2` will be unzipped if not already done in the convenient path. - **NOTE**: An environment variable named `$VPSIM_HOME` will be set to point to the root directory of VPSim. - **NOTE**: `setup.sh` will not modify your `~/.bashrc`. You need to re-source `setup.sh` each time you change the terminal. Getting Started Move to ( /GPP ) directory and check your configuration file. Now you are good to run your first simulation: python3 gpp.py This should boot the Busybox Linux on an ARMv8 system with internet connectivity. Login as root (no password). To end the simulation, enter the following command in your simulated userspace: sesam quit Dive in gpp.py to see how to customize your own architecture Getting to know more about VPSim To have an idea of what you can do with VPSim, please follow the README.md file in the following sub-directory: /GPP Getting to test VPSim and run your first simulation To try VPSim and customize your architecture to simulate, please refer to the Simulation section.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#demo-package-contents","text":"bin (/bin): Contains vpsim binary. After each simulation run, a specific folder is created here with files & results of the simulated architecture. lib (/lib): holds the modified qemu library ( ./qemu/vpsim-qemu.so ) GPP (/GPP): Contains configuration python scripts as well as linux kernel and disk image. Configure and simulate a multi-core ARMv8 system running a minimal operating system. Python (/Python): Platforms/armv8_platform.py : gives a versatile, generic ARMv8 System script that generates and configures its components based on a higher-level description. In order to abstract away for the user the whole work of composition. Libs/dt.py : generates the Device Tree to automate the process of configuring hardware components for the simulated architecture. Libs/vpsim.py : generates the final xml of the simulated architecture. SESAM userspace (/SESAM_userspace) : source code for a user space software tool used to control over the simulator for monitoring purposes and collect statistics following the execution of a specific user application and makes it possible to perform an entire exploration task.","title":"Demo Package Contents"},{"location":"installation/#clone-build","text":"Clone this git repository and update its submodules: git clone git@github.com:CEA-LIST/VPSim.git cd vpsim git submodule init git submodule update --recursive Build targets and copy artifacts to the release directory ./vpsim-release sub-directory: to do so, we configured a custom command in CMakeLists that rename and copy the targets to the appropriate folder in the release test environment mkdir build && cd build cmake .. make all -j cd ../","title":"Clone &amp; Build"},{"location":"installation/#requirements","text":"You will need to install dtc device tree compiler: apt install device-tree-compiler To build VPSim & the modified QEMU on a fresh Ubuntu 22.04 LTS installation, you will need to install these libraries: apt install pkg-config apt install libglib2.0-dev apt install libpixman-1-dev For the modified qemu, as it is based on an old version you will need Python2 to be installed : apt install python2 and export it in your shell: export PYTHON=/usr/bin/python2 Now your environment is set, please follow the following steps:","title":"Requirements"},{"location":"installation/#configure","text":"Once you realized the steps in the parent README, you can verify the existence of these two main targets as follows: - vpsim -> \"vpsim_release/bin/\" - qemu-system-aarch64 renamed to vpsim-qemu.so -> \"vpsim_release/lib/qemu/\" Configure environment variables by sourcing the ( setup.sh ) script: source setup.sh - **NOTE**: This command must be run in the root directory of VPSim release. - **NOTE**: The disk image `busybox.qcow2` will be unzipped if not already done in the convenient path. - **NOTE**: An environment variable named `$VPSIM_HOME` will be set to point to the root directory of VPSim. - **NOTE**: `setup.sh` will not modify your `~/.bashrc`. You need to re-source `setup.sh` each time you change the terminal.","title":"Configure"},{"location":"installation/#getting-started","text":"Move to ( /GPP ) directory and check your configuration file. Now you are good to run your first simulation: python3 gpp.py This should boot the Busybox Linux on an ARMv8 system with internet connectivity. Login as root (no password). To end the simulation, enter the following command in your simulated userspace: sesam quit Dive in gpp.py to see how to customize your own architecture","title":"Getting Started"},{"location":"installation/#getting-to-know-more-about-vpsim","text":"To have an idea of what you can do with VPSim, please follow the README.md file in the following sub-directory: /GPP","title":"Getting to know more about VPSim"},{"location":"installation/#getting-to-test-vpsim-and-run-your-first-simulation","text":"To try VPSim and customize your architecture to simulate, please refer to the Simulation section.","title":"Getting to test VPSim and run your first simulation"},{"location":"simulation/","text":"Simulation If you have entirely installed VPSim, you can now launch simulations. To do so, i will explain a few things you need to know before starting. Models In the Release directory you will find a GPP directory. This directory contains a python file descriptor of the model of General Purpose Processors (GPP) that will be used for the simulation. This file is called gpp.py . You can modify this file to change the model of the GPP. For futher information, there is a README file in the GPP directory. Launching a simulation To launch a simulation, you juste have to run the gpp.py file: python3 gpp.py Then login as root with no password. You will then be able to access the simulated system. Benchmarking To benchmark the system, you can use the sesam tool. To use it during the simulation, you can type: sesam benchmark ./[my_program] Where [my_program] is the program you want to benchmark. This will run the program and give you the results of the benchmark in a .log file located in the /bin/.EPI_GPP_VP[date]--[uniqId] directory of the release. Ending a simulation To end the simulation, juste type: sesam quit Conclusion You now know how to launch a simulation with VPSim. You can start exploring the design space of your architecture and validate your design choices.","title":"Simulation"},{"location":"simulation/#simulation","text":"If you have entirely installed VPSim, you can now launch simulations. To do so, i will explain a few things you need to know before starting.","title":"Simulation"},{"location":"simulation/#models","text":"In the Release directory you will find a GPP directory. This directory contains a python file descriptor of the model of General Purpose Processors (GPP) that will be used for the simulation. This file is called gpp.py . You can modify this file to change the model of the GPP. For futher information, there is a README file in the GPP directory.","title":"Models"},{"location":"simulation/#launching-a-simulation","text":"To launch a simulation, you juste have to run the gpp.py file: python3 gpp.py Then login as root with no password. You will then be able to access the simulated system.","title":"Launching a simulation"},{"location":"simulation/#benchmarking","text":"To benchmark the system, you can use the sesam tool. To use it during the simulation, you can type: sesam benchmark ./[my_program] Where [my_program] is the program you want to benchmark. This will run the program and give you the results of the benchmark in a .log file located in the /bin/.EPI_GPP_VP[date]--[uniqId] directory of the release.","title":"Benchmarking"},{"location":"simulation/#ending-a-simulation","text":"To end the simulation, juste type: sesam quit","title":"Ending a simulation"},{"location":"simulation/#conclusion","text":"You now know how to launch a simulation with VPSim. You can start exploring the design space of your architecture and validate your design choices.","title":"Conclusion"},{"location":"uml/","text":"UML In this section, we will provide some UML diagrams to help you understand the architecture of VPSim. Here is a global representation of VPSim: Global representation of VPSim Class Diagrams Release link to download the visual paradigm project In this file, you will also find the sequence diagram of a simulation in the VPSim release. Dynamic Instanciation of SystemC modules (in VPSim Binary) link to download the visual paradigm project","title":"UML"},{"location":"uml/#uml","text":"In this section, we will provide some UML diagrams to help you understand the architecture of VPSim. Here is a global representation of VPSim:","title":"UML"},{"location":"uml/#global-representation-of-vpsim","text":"","title":"Global representation of VPSim"},{"location":"uml/#class-diagrams","text":"","title":"Class Diagrams"},{"location":"uml/#release","text":"link to download the visual paradigm project In this file, you will also find the sequence diagram of a simulation in the VPSim release.","title":"Release"},{"location":"uml/#dynamic-instanciation-of-systemc-modules-in-vpsim-binary","text":"link to download the visual paradigm project","title":"Dynamic Instanciation of SystemC modules (in VPSim Binary)"}]}